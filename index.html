<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Health Weather Metrics</title>

  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --bg-primary: #0f1117;
      --bg-card: #1a1d27;
      --bg-card-hover: #1e2230;
      --text-primary: #e4e6ef;
      --text-secondary: #8b8fa3;
      --accent-blue: #4a9eff;
      --accent-green: #34d399;
      --accent-yellow: #fbbf24;
      --accent-red: #f87171;
      --accent-purple: #a78bfa;
      --accent-orange: #fb923c;
      --border-color: #2a2e3d;
      --radius: 12px;
      --shadow: 0 4px 24px rgba(0,0,0,0.3);
      --font-mono: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
      --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
    }

    body {
      font-family: var(--font-sans);
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      line-height: 1.5;
    }

    /* Header */
    .header {
      padding: 24px 32px;
      display: flex;
      align-items: baseline;
      gap: 16px;
      flex-wrap: wrap;
    }
    .header h1 {
      font-size: 1.5rem;
      font-weight: 600;
      letter-spacing: -0.02em;
    }
    .header .location {
      font-size: 0.875rem;
      color: var(--text-secondary);
      font-family: var(--font-mono);
    }

    /* Location switcher — inline in header */
    .location-switcher {
      position: relative;
      display: inline-flex;
      align-items: center;
    }
    /* Collapsed: the clickable label */
    .loc-label {
      font-size: 0.875rem;
      color: var(--text-secondary);
      font-family: var(--font-mono);
      cursor: pointer;
      padding: 4px 10px;
      border-radius: 6px;
      border: 1px solid transparent;
      transition: border-color 0.15s, background 0.15s;
      user-select: none;
      white-space: nowrap;
    }
    .loc-label:hover {
      border-color: var(--border-color);
      background: var(--bg-card);
    }
    /* Expanded: the edit popover */
    .loc-editor {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 100;
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.45);
      padding: 10px 12px;
      flex-direction: column;
      gap: 8px;
      min-width: 320px;
    }
    .loc-editor.open {
      display: flex;
    }
    .loc-editor-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .loc-editor input[type="text"] {
      flex: 1;
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 7px 10px;
      color: var(--text-primary);
      font-family: var(--font-sans);
      font-size: 0.84rem;
      outline: none;
      transition: border-color 0.15s;
      min-width: 0;
    }
    .loc-editor input[type="text"]:focus {
      border-color: var(--accent-blue);
    }
    .loc-editor input[type="text"]::placeholder {
      color: #555a6e;
    }
    .loc-editor-btn {
      padding: 7px 14px;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      background: var(--accent-blue);
      color: #fff;
      font-size: 0.8rem;
      font-weight: 600;
      cursor: pointer;
      font-family: var(--font-sans);
      transition: opacity 0.15s;
      white-space: nowrap;
    }
    .loc-editor-btn:hover { opacity: 0.85; }
    .loc-editor-footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .loc-editor-footer label {
      font-size: 0.75rem;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 5px;
      cursor: pointer;
      user-select: none;
    }
    .loc-editor-footer input[type="checkbox"] {
      accent-color: var(--accent-blue);
      width: 13px;
      height: 13px;
      cursor: pointer;
    }
    .loc-error {
      font-size: 0.75rem;
      color: var(--accent-red);
    }

    @media (max-width: 480px) {
      .loc-editor { min-width: 260px; }
    }

    /* Dashboard Grid */
    .dashboard {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      padding: 0 32px 32px;
      max-width: 1200px;
      margin: 0 auto;
    }

    /* Cards */
    .card {
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    .card-pressure { grid-column: 1 / -1; }
    .card-astro { grid-row: span 2; }

    .card-top {
      height: 3px;
      flex-shrink: 0;
    }
    .card-pressure .card-top { background: linear-gradient(90deg, var(--accent-blue), #7dd3fc); }
    .card-moon .card-top { background: linear-gradient(90deg, var(--accent-purple), #c4b5fd); }
    .card-astro .card-top { background: linear-gradient(90deg, #9333ea, #ec4899); }
    .card-solar .card-top { background: linear-gradient(90deg, var(--accent-orange), var(--accent-yellow)); }
    .card-temp .card-top { background: linear-gradient(90deg, #10b981, #34d399); }

    .card-header {
      padding: 16px 20px 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .card-header h2 {
      font-size: 0.875rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-secondary);
    }

    .card-body {
      padding: 16px 20px 20px;
      flex: 1;
      position: relative;
      min-height: 80px;
    }

    .card-footer {
      padding: 12px 20px;
      border-top: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      color: var(--text-secondary);
      font-family: var(--font-mono);
    }

    /* Chart container */
    .chart-wrap {
      position: relative;
      height: 260px;
    }

    /* Trend badge */
    .trend { font-weight: 600; }
    .trend.rising { color: var(--accent-green); }
    .trend.falling { color: var(--accent-red); }
    .trend.steady { color: var(--text-secondary); }

    /* Moon card */
    .moon-display {
      display: flex;
      align-items: center;
      gap: 20px;
    }
    .moon-emoji {
      font-size: 3.5rem;
      line-height: 1;
    }
    .moon-info { flex: 1; }
    .moon-sign-name {
      font-size: 1.4rem;
      font-weight: 600;
    }
    .moon-sign-symbol {
      color: var(--accent-purple);
      margin-right: 6px;
    }
    .moon-details {
      margin-top: 10px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 0.85rem;
      color: var(--text-secondary);
    }
    .moon-details span strong {
      color: var(--text-primary);
      font-family: var(--font-mono);
      font-weight: 500;
    }

    /* Temperature card */
    .temp-display {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .temp-current {
      font-size: 3.5rem;
      font-weight: 700;
      font-family: var(--font-mono);
      color: var(--text-primary);
      line-height: 1;
    }
    .temp-current .unit {
      font-size: 1.5rem;
      color: var(--text-secondary);
      font-weight: 400;
    }
    .temp-details {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 0.9rem;
      color: var(--text-secondary);
    }
    .temp-details span strong {
      color: var(--text-primary);
      font-family: var(--font-mono);
      font-weight: 500;
    }

    /* Astrological Events card */
    .astro-event-list {
      list-style: none;
      display: flex;
      flex-direction: column;
      gap: 0;
      max-height: 320px;
      overflow-y: auto;
    }
    .astro-event-item {
      display: flex;
      align-items: flex-start;
      gap: 12px;
      padding: 12px 0;
      border-bottom: 1px solid var(--border-color);
      transition: background 0.15s;
    }
    .astro-event-item:last-child { border-bottom: none; }
    .astro-event-item:hover {
      background: rgba(167, 139, 250, 0.03);
      margin: 0 -8px;
      padding-left: 8px;
      padding-right: 8px;
      border-radius: 6px;
    }
    .astro-event-icon {
      width: 32px;
      height: 32px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
      flex-shrink: 0;
      font-weight: 600;
    }
    .astro-event-icon.retrograde {
      background: rgba(248, 113, 113, 0.15);
      color: var(--accent-red);
    }
    .astro-event-icon.eclipse {
      background: rgba(251, 191, 36, 0.15);
      color: var(--accent-yellow);
    }
    .astro-event-icon.position {
      background: rgba(167, 139, 250, 0.15);
      color: var(--accent-purple);
    }
    .astro-event-icon.node {
      background: rgba(74, 158, 255, 0.15);
      color: var(--accent-blue);
    }
    .astro-event-content {
      flex: 1;
      min-width: 0;
    }
    .astro-event-title {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 2px;
    }
    .astro-event-detail {
      font-size: 0.8rem;
      color: var(--text-secondary);
      font-family: var(--font-mono);
      line-height: 1.4;
    }
    .astro-event-date {
      font-size: 0.75rem;
      color: var(--accent-purple);
      margin-top: 3px;
      font-family: var(--font-mono);
    }
    .no-astro-events {
      color: var(--text-secondary);
      font-style: italic;
      padding: 20px 0;
      text-align: center;
      font-size: 0.85rem;
    }
    .astro-event-list::-webkit-scrollbar { width: 4px; }
    .astro-event-list::-webkit-scrollbar-track { background: transparent; }
    .astro-event-list::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 2px; }

    /* Solar card */
    .solar-summary {
      display: flex;
      gap: 16px;
      margin-bottom: 14px;
      flex-wrap: wrap;
    }
    .solar-stat {
      background: rgba(251,146,60,0.08);
      border: 1px solid rgba(251,146,60,0.15);
      border-radius: 8px;
      padding: 8px 14px;
      font-size: 0.8rem;
    }
    .solar-stat .val {
      font-size: 1.2rem;
      font-weight: 700;
      font-family: var(--font-mono);
      color: var(--accent-orange);
      display: block;
    }

    .flare-list {
      list-style: none;
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 240px;
      overflow-y: auto;
    }
    .flare-item {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 0.82rem;
      padding: 6px 0;
      border-bottom: 1px solid var(--border-color);
    }
    .flare-item:last-child { border-bottom: none; }

    .flare-badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 4px;
      font-family: var(--font-mono);
      font-weight: 700;
      font-size: 0.78rem;
      min-width: 48px;
      text-align: center;
      flex-shrink: 0;
    }
    .flare-badge.class-B { background: #374151; color: #9ca3af; }
    .flare-badge.class-C { background: rgba(52,211,153,0.15); color: var(--accent-green); }
    .flare-badge.class-M { background: rgba(251,191,36,0.15); color: var(--accent-yellow); }
    .flare-badge.class-X { background: rgba(248,113,113,0.15); color: var(--accent-red); }

    .flare-time {
      color: var(--text-secondary);
      font-family: var(--font-mono);
      font-size: 0.78rem;
      flex-shrink: 0;
    }
    .flare-source {
      color: var(--text-secondary);
      font-size: 0.75rem;
    }
    .no-flares {
      color: var(--text-secondary);
      font-style: italic;
      padding: 20px 0;
      text-align: center;
    }

    /* Loading skeleton */
    .card.loading .card-body-content { visibility: hidden; }
    .card.loading .card-body::after {
      content: '';
      position: absolute;
      inset: 16px 20px;
      border-radius: 8px;
      background: linear-gradient(90deg, var(--bg-card) 25%, #252936 50%, var(--bg-card) 75%);
      background-size: 200% 100%;
      animation: shimmer 1.5s ease-in-out infinite;
    }
    @keyframes shimmer {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    /* Error state */
    .error-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 20px;
      text-align: center;
    }
    .error-state .error-icon {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: rgba(248,113,113,0.12);
      color: var(--accent-red);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 1.1rem;
    }
    .error-state .error-msg {
      font-size: 0.82rem;
      color: var(--text-secondary);
    }
    .retry-btn {
      margin-top: 4px;
      padding: 6px 16px;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      background: transparent;
      color: var(--accent-blue);
      font-size: 0.8rem;
      cursor: pointer;
      font-family: var(--font-sans);
    }
    .retry-btn:hover { background: rgba(74,158,255,0.08); }

    /* Footer */
    .footer {
      padding: 16px 32px 24px;
      max-width: 1200px;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.78rem;
      color: var(--text-secondary);
      flex-wrap: wrap;
      gap: 8px;
    }
    .footer button {
      padding: 6px 18px;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      background: var(--bg-card);
      color: var(--text-primary);
      font-size: 0.8rem;
      cursor: pointer;
      font-family: var(--font-sans);
      transition: background 0.15s;
    }
    .footer button:hover { background: var(--bg-card-hover); }

    /* Responsive */
    @media (max-width: 768px) {
      .header { padding: 20px 16px; }
      .dashboard {
        grid-template-columns: 1fr;
        padding: 0 16px 16px;
      }
      .card-pressure { grid-column: 1; }
      .card-astro { grid-row: auto; }
      .footer { padding: 12px 16px 20px; }
      .chart-wrap { height: 220px; }
    }
    @media (max-width: 480px) {
      .header h1 { font-size: 1.2rem; }
      .moon-emoji { font-size: 2.5rem; }
      .moon-sign-name { font-size: 1.1rem; }
    }

    /* Scrollbar for flare list */
    .flare-list::-webkit-scrollbar { width: 4px; }
    .flare-list::-webkit-scrollbar-track { background: transparent; }
    .flare-list::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 2px; }
  </style>
</head>
<body>

  <header class="header">
    <h1>Health Weather Metrics</h1>
    <div class="location-switcher" id="location-switcher">
      <span class="loc-label" id="loc-label">Detecting location...</span>
      <div class="loc-editor" id="loc-editor">
        <div class="loc-editor-row">
          <input type="text" id="location-input" placeholder="City name or lat, lon">
          <button class="loc-editor-btn" id="location-go-btn">Go</button>
        </div>
        <div class="loc-editor-footer">
          <label>
            <input type="checkbox" id="auto-detect-toggle" checked>
            Auto-detect on load
          </label>
          <span class="loc-error" id="location-error"></span>
        </div>
      </div>
    </div>
  </header>

  <main class="dashboard">
    <!-- Barometric Pressure -->
    <section class="card card-pressure loading" id="card-pressure">
      <div class="card-top"></div>
      <div class="card-header">
        <h2>Barometric Pressure &mdash; 3 Day Trend</h2>
      </div>
      <div class="card-body">
        <div class="card-body-content">
          <div class="chart-wrap">
            <canvas id="pressure-chart"></canvas>
          </div>
        </div>
      </div>
      <div class="card-footer">
        <span id="current-pressure">Current: -- hPa</span>
        <span id="pressure-trend" class="trend">Trend: --</span>
      </div>
    </section>

    <!-- Temperature -->
    <section class="card card-temp loading" id="card-temp">
      <div class="card-top"></div>
      <div class="card-header">
        <h2>Temperature</h2>
      </div>
      <div class="card-body">
        <div class="card-body-content">
          <div class="temp-display">
            <div class="temp-current" id="temp-current"></div>
            <div class="temp-details" id="temp-details"></div>
          </div>
        </div>
      </div>
      <div class="card-footer">
        <span id="temp-range">Range: --</span>
        <span id="temp-trend" class="trend">Trend: --</span>
      </div>
    </section>

    <!-- Moon Sign -->
    <section class="card card-moon loading" id="card-moon">
      <div class="card-top"></div>
      <div class="card-header">
        <h2>Current Moon</h2>
      </div>
      <div class="card-body">
        <div class="card-body-content">
          <div class="moon-display">
            <div class="moon-emoji" id="moon-emoji"></div>
            <div class="moon-info">
              <div class="moon-sign-name" id="moon-sign-name"></div>
              <div class="moon-details" id="moon-details"></div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Solar Flare Activity -->
    <section class="card card-solar loading" id="card-solar">
      <div class="card-top"></div>
      <div class="card-header">
        <h2>Solar Flare Activity</h2>
      </div>
      <div class="card-body">
        <div class="card-body-content">
          <div class="solar-summary" id="solar-summary"></div>
          <ul class="flare-list" id="flare-list"></ul>
        </div>
      </div>
    </section>

    <!-- Astrological Events -->
    <section class="card card-astro loading" id="card-astro">
      <div class="card-top"></div>
      <div class="card-header">
        <h2>Astrological Events</h2>
      </div>
      <div class="card-body">
        <div class="card-body-content">
          <ul class="astro-event-list" id="astro-event-list"></ul>
        </div>
      </div>
    </section>
  </main>

  <footer class="footer">
    <span>Last updated: <span id="last-updated">--</span></span>
    <button id="refresh-btn">Refresh</button>
  </footer>

  <!-- CDN Dependencies -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/date-fns@3.6.0/cdn.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
  <script src="https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.19/astronomy.browser.min.js"></script>

  <script>
  (function() {
    'use strict';

    // ==========================================
    // CONFIGURATION
    // ==========================================
    var CONFIG = {
      GEOLOCATION_URL: 'https://ipapi.co/json/',
      GEOCODING_URL: '/.netlify/functions/geocode',
      WEATHER_URL: '/.netlify/functions/weather',
      SOLAR_FLARES_URL: '/.netlify/functions/solar-flares',
      PAST_DAYS: 3,
      SOLAR_LOOKBACK_DAYS: 7,
      DEFAULT_LOCATION: { lat: 40.7128, lon: -74.006, city: 'New York', region: 'NY' },
      STORAGE_KEY: 'hwm_location_prefs',
      ASTRO_LOOKFORWARD_DAYS: 180,
      RETROGRADE_CHECK_DAYS: 7,
      PLANETS_TO_CHECK: ['Mercury', 'Venus', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']
    };

    var ZODIAC = [
      { name: 'Aries',       symbol: '\u2648' },
      { name: 'Taurus',      symbol: '\u2649' },
      { name: 'Gemini',      symbol: '\u264A' },
      { name: 'Cancer',      symbol: '\u264B' },
      { name: 'Leo',         symbol: '\u264C' },
      { name: 'Virgo',       symbol: '\u264D' },
      { name: 'Libra',       symbol: '\u264E' },
      { name: 'Scorpio',     symbol: '\u264F' },
      { name: 'Sagittarius', symbol: '\u2650' },
      { name: 'Capricorn',   symbol: '\u2651' },
      { name: 'Aquarius',    symbol: '\u2652' },
      { name: 'Pisces',      symbol: '\u2653' }
    ];

    // ==========================================
    // STATE
    // ==========================================
    var pressureChart = null;

    // ==========================================
    // DOM REFERENCES
    // ==========================================
    var locSwitcher = document.getElementById('location-switcher');
    var locLabel = document.getElementById('loc-label');
    var locEditor = document.getElementById('loc-editor');
    var autoDetectToggle = document.getElementById('auto-detect-toggle');
    var locationInput = document.getElementById('location-input');
    var locationGoBtn = document.getElementById('location-go-btn');
    var locationError = document.getElementById('location-error');

    // ==========================================
    // UTILITIES
    // ==========================================
    function fetchJSON(url, timeoutMs) {
      timeoutMs = timeoutMs || 10000;
      var controller = new AbortController();
      var timer = setTimeout(function() { controller.abort(); }, timeoutMs);
      return fetch(url, { signal: controller.signal })
        .then(function(res) {
          clearTimeout(timer);
          if (!res.ok) throw new Error('HTTP ' + res.status);
          return res.json();
        });
    }

    function setLoading(cardId) {
      var card = document.getElementById(cardId);
      card.classList.add('loading');
      card.classList.remove('error');
    }

    function clearLoading(cardId) {
      document.getElementById(cardId).classList.remove('loading');
    }

    function showError(cardId, message) {
      var card = document.getElementById(cardId);
      card.classList.remove('loading');
      var body = card.querySelector('.card-body-content');
      body.innerHTML =
        '<div class="error-state">' +
          '<div class="error-icon">!</div>' +
          '<div class="error-msg">' + message + '</div>' +
          '<button class="retry-btn" onclick="window.__refresh()">Retry</button>' +
        '</div>';
    }

    function formatDateTime(dateStr) {
      var d = new Date(dateStr);
      return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) +
        ', ' + d.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
    }

    function formatDateISO(date) {
      var y = date.getFullYear();
      var m = String(date.getMonth() + 1).padStart(2, '0');
      var d = String(date.getDate()).padStart(2, '0');
      return y + '-' + m + '-' + d;
    }

    // ==========================================
    // LOCATION PREFERENCES (localStorage)
    // ==========================================
    function savePrefs(prefs) {
      try { localStorage.setItem(CONFIG.STORAGE_KEY, JSON.stringify(prefs)); } catch (e) {}
    }

    function loadPrefs() {
      try {
        var raw = localStorage.getItem(CONFIG.STORAGE_KEY);
        if (raw) return JSON.parse(raw);
      } catch (e) {}
      return null;
    }

    // ==========================================
    // GEOLOCATION
    // ==========================================
    function detectLocationAuto() {
      return fetchJSON(CONFIG.GEOLOCATION_URL)
        .then(function(data) {
          return {
            lat: data.latitude,
            lon: data.longitude,
            city: data.city,
            region: data.region
          };
        })
        .catch(function() {
          return new Promise(function(resolve) {
            if (!navigator.geolocation) {
              resolve(CONFIG.DEFAULT_LOCATION);
              return;
            }
            navigator.geolocation.getCurrentPosition(
              function(pos) {
                resolve({
                  lat: pos.coords.latitude,
                  lon: pos.coords.longitude,
                  city: 'Your Location',
                  region: ''
                });
              },
              function() {
                resolve(CONFIG.DEFAULT_LOCATION);
              },
              { timeout: 5000 }
            );
          });
        });
    }

    function geocodeCity(query) {
      // Check if the input looks like coordinates (e.g. "45.5, -122.6")
      var coordMatch = query.match(/^\s*(-?\d+\.?\d*)\s*[,\s]\s*(-?\d+\.?\d*)\s*$/);
      if (coordMatch) {
        var lat = parseFloat(coordMatch[1]);
        var lon = parseFloat(coordMatch[2]);
        if (lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180) {
          return Promise.resolve({
            lat: lat,
            lon: lon,
            city: lat.toFixed(2) + ', ' + lon.toFixed(2),
            region: ''
          });
        }
      }

      // Otherwise geocode via Netlify Function
      var url = CONFIG.GEOCODING_URL + '?name=' + encodeURIComponent(query) + '&count=1&language=en&format=json';
      return fetchJSON(url).then(function(data) {
        if (!data.results || data.results.length === 0) {
          throw new Error('Location not found');
        }
        var r = data.results[0];
        return {
          lat: r.latitude,
          lon: r.longitude,
          city: r.name,
          region: r.admin1 || r.country || ''
        };
      });
    }

    function resolveLocationForLoad() {
      locationError.textContent = '';

      // On page load: auto-detect if checked, otherwise use saved location
      if (autoDetectToggle.checked) {
        return detectLocationAuto();
      }

      var prefs = loadPrefs();
      if (prefs && prefs.manual) {
        return Promise.resolve(prefs.manual);
      }
      return Promise.resolve(CONFIG.DEFAULT_LOCATION);
    }

    function resolveLocationManual(query) {
      locationError.textContent = '';
      return geocodeCity(query).catch(function(err) {
        locationError.textContent = 'Could not find "' + query + '".';
        return null;
      });
    }

    // ==========================================
    // BAROMETRIC PRESSURE
    // ==========================================
    function fetchPressure(lat, lon) {
      var url = CONFIG.WEATHER_URL +
        '?latitude=' + lat +
        '&longitude=' + lon +
        '&hourly=surface_pressure' +
        '&past_days=' + CONFIG.PAST_DAYS;
      return fetchJSON(url).then(function(data) {
        var times = [];
        var pressures = [];
        for (var i = 0; i < data.hourly.time.length; i++) {
          if (data.hourly.surface_pressure[i] != null) {
            times.push(data.hourly.time[i]);
            pressures.push(data.hourly.surface_pressure[i]);
          }
        }
        return { times: times, pressures: pressures };
      });
    }

    function calculateTrend(pressures) {
      if (pressures.length < 12) return { direction: 'steady', arrow: '\u2192', delta: 0 };
      var recent = pressures.slice(-6);
      var prior = pressures.slice(-12, -6);
      var avgRecent = recent.reduce(function(a, b) { return a + b; }, 0) / recent.length;
      var avgPrior = prior.reduce(function(a, b) { return a + b; }, 0) / prior.length;
      var delta = avgRecent - avgPrior;
      if (delta > 1) return { direction: 'rising', arrow: '\u2191', delta: delta };
      if (delta < -1) return { direction: 'falling', arrow: '\u2193', delta: delta };
      return { direction: 'steady', arrow: '\u2192', delta: delta };
    }

    function renderPressure(data) {
      clearLoading('card-pressure');
      if (pressureChart) { pressureChart.destroy(); }

      var ctx = document.getElementById('pressure-chart').getContext('2d');
      var gradient = ctx.createLinearGradient(0, 0, 0, 260);
      gradient.addColorStop(0, 'rgba(74, 158, 255, 0.15)');
      gradient.addColorStop(1, 'rgba(74, 158, 255, 0)');

      pressureChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: data.times.map(function(t) { return new Date(t); }),
          datasets: [{
            label: 'Surface Pressure (hPa)',
            data: data.pressures,
            borderColor: '#4a9eff',
            backgroundColor: gradient,
            fill: true,
            tension: 0.3,
            pointRadius: 0,
            pointHitRadius: 10,
            borderWidth: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { mode: 'index', intersect: false },
          plugins: {
            legend: { display: false },
            tooltip: {
              backgroundColor: '#1a1d27',
              borderColor: '#2a2e3d',
              borderWidth: 1,
              titleColor: '#8b8fa3',
              bodyColor: '#e4e6ef',
              bodyFont: { family: "'SF Mono', monospace" },
              padding: 10,
              callbacks: {
                label: function(ctx) {
                  return ctx.parsed.y.toFixed(1) + ' hPa';
                }
              }
            }
          },
          scales: {
            x: {
              type: 'time',
              time: { unit: 'hour', displayFormats: { hour: 'MMM d, ha' }, tooltipFormat: 'MMM d, h:mm a' },
              ticks: { color: '#8b8fa3', maxRotation: 0, autoSkipPadding: 30, font: { size: 11 } },
              grid: { color: 'rgba(42, 46, 61, 0.5)' }
            },
            y: {
              ticks: { color: '#8b8fa3', font: { size: 11, family: "'SF Mono', monospace" } },
              grid: { color: 'rgba(42, 46, 61, 0.5)' }
            }
          }
        }
      });

      // Current value
      var latest = data.pressures[data.pressures.length - 1];
      document.getElementById('current-pressure').textContent = 'Current: ' + latest.toFixed(1) + ' hPa';

      // Trend
      var trend = calculateTrend(data.pressures);
      var trendEl = document.getElementById('pressure-trend');
      trendEl.textContent = 'Trend: ' + trend.arrow + ' ' + trend.direction.charAt(0).toUpperCase() + trend.direction.slice(1) +
        ' (' + (trend.delta > 0 ? '+' : '') + trend.delta.toFixed(1) + ' hPa)';
      trendEl.className = 'trend ' + trend.direction;
    }

    // ==========================================
    // TEMPERATURE
    // ==========================================
    function fetchTemperature(lat, lon) {
      var url = CONFIG.WEATHER_URL +
        '?latitude=' + lat +
        '&longitude=' + lon +
        '&hourly=temperature_2m,apparent_temperature' +
        '&daily=temperature_2m_max,temperature_2m_min' +
        '&temperature_unit=fahrenheit' +
        '&forecast_days=1' +
        '&past_days=' + CONFIG.PAST_DAYS;
      return fetchJSON(url).then(function(data) {
        var times = [];
        var temps = [];
        var feelsLike = [];

        // Get hourly data
        for (var i = 0; i < data.hourly.time.length; i++) {
          if (data.hourly.temperature_2m[i] != null) {
            times.push(data.hourly.time[i]);
            temps.push(data.hourly.temperature_2m[i]);
            feelsLike.push(data.hourly.apparent_temperature[i]);
          }
        }

        // Get today's min/max
        var todayMin = data.daily.temperature_2m_min[data.daily.temperature_2m_min.length - 1];
        var todayMax = data.daily.temperature_2m_max[data.daily.temperature_2m_max.length - 1];

        return {
          times: times,
          temps: temps,
          feelsLike: feelsLike,
          todayMin: todayMin,
          todayMax: todayMax
        };
      });
    }

    function calculateTempTrend(temps) {
      if (temps.length < 12) return { direction: 'steady', arrow: '\u2192', delta: 0 };
      var recent = temps.slice(-6);
      var prior = temps.slice(-12, -6);
      var avgRecent = recent.reduce(function(a, b) { return a + b; }, 0) / recent.length;
      var avgPrior = prior.reduce(function(a, b) { return a + b; }, 0) / prior.length;
      var delta = avgRecent - avgPrior;
      if (delta > 2) return { direction: 'rising', arrow: '\u2191', delta: delta };
      if (delta < -2) return { direction: 'falling', arrow: '\u2193', delta: delta };
      return { direction: 'steady', arrow: '\u2192', delta: delta };
    }

    function renderTemperature(data) {
      clearLoading('card-temp');

      // Current temperature
      var currentTemp = data.temps[data.temps.length - 1];
      var currentFeels = data.feelsLike[data.feelsLike.length - 1];

      document.getElementById('temp-current').innerHTML =
        Math.round(currentTemp) + '<span class="unit">\u00B0F</span>';

      document.getElementById('temp-details').innerHTML =
        '<span>Feels like: <strong>' + Math.round(currentFeels) + '\u00B0F</strong></span>' +
        '<span>Today\'s high: <strong>' + Math.round(data.todayMax) + '\u00B0F</strong></span>' +
        '<span>Today\'s low: <strong>' + Math.round(data.todayMin) + '\u00B0F</strong></span>';

      // Range
      document.getElementById('temp-range').textContent =
        'Range: ' + Math.round(data.todayMin) + '\u00B0 - ' + Math.round(data.todayMax) + '\u00B0F';

      // Trend
      var trend = calculateTempTrend(data.temps);
      var trendEl = document.getElementById('temp-trend');
      trendEl.textContent = 'Trend: ' + trend.arrow + ' ' +
        trend.direction.charAt(0).toUpperCase() + trend.direction.slice(1) +
        ' (' + (trend.delta > 0 ? '+' : '') + trend.delta.toFixed(1) + '\u00B0F)';
      trendEl.className = 'trend ' + trend.direction;
    }

    // ==========================================
    // MOON SIGN
    // ==========================================
    function getMoonPhaseName(angle) {
      if (angle < 22.5 || angle >= 337.5) return 'New Moon';
      if (angle < 67.5) return 'Waxing Crescent';
      if (angle < 112.5) return 'First Quarter';
      if (angle < 157.5) return 'Waxing Gibbous';
      if (angle < 202.5) return 'Full Moon';
      if (angle < 247.5) return 'Waning Gibbous';
      if (angle < 292.5) return 'Last Quarter';
      return 'Waning Crescent';
    }

    function getMoonPhaseEmoji(angle) {
      if (angle < 22.5 || angle >= 337.5) return '\uD83C\uDF11';
      if (angle < 67.5)  return '\uD83C\uDF12';
      if (angle < 112.5) return '\uD83C\uDF13';
      if (angle < 157.5) return '\uD83C\uDF14';
      if (angle < 202.5) return '\uD83C\uDF15';
      if (angle < 247.5) return '\uD83C\uDF16';
      if (angle < 292.5) return '\uD83C\uDF17';
      return '\uD83C\uDF18';
    }

    function calculateMoon() {
      var now = new Date();
      var moon = Astronomy.EclipticGeoMoon(now);
      var lon = moon.lon;
      if (lon < 0) lon += 360;
      var signIndex = Math.floor(lon / 30) % 12;
      var sign = ZODIAC[signIndex];

      var phaseAngle = Astronomy.MoonPhase(now);
      var phaseName = getMoonPhaseName(phaseAngle);
      var emoji = getMoonPhaseEmoji(phaseAngle);

      // Illumination from phase angle
      var illum = (1 - Math.cos(phaseAngle * Math.PI / 180)) / 2 * 100;

      return {
        signName: sign.name,
        signSymbol: sign.symbol,
        phaseName: phaseName,
        emoji: emoji,
        illumination: illum,
        longitude: lon,
        degrees: (lon % 30).toFixed(1)
      };
    }

    function renderMoon(data) {
      clearLoading('card-moon');
      document.getElementById('moon-emoji').textContent = data.emoji;
      document.getElementById('moon-sign-name').innerHTML =
        '<span class="moon-sign-symbol">' + data.signSymbol + '</span>' +
        'Moon in ' + data.signName;
      document.getElementById('moon-details').innerHTML =
        '<span>Phase: <strong>' + data.phaseName + '</strong></span>' +
        '<span>Illumination: <strong>' + data.illumination.toFixed(0) + '%</strong></span>' +
        '<span>Ecliptic longitude: <strong>' + data.longitude.toFixed(1) + '\u00B0</strong> (' + data.degrees + '\u00B0 ' + data.signName + ')</span>';
    }

    // ==========================================
    // ASTROLOGICAL EVENTS
    // ==========================================
    function getPlanetEmoji(planetName) {
      var emojis = {
        'Mercury': '\u263F',
        'Venus': '\u2640',
        'Mars': '\u2642',
        'Jupiter': '\u2643',
        'Saturn': '\u2644',
        'Uranus': '\u2645',
        'Neptune': '\u2646'
      };
      return emojis[planetName] || '\u2609';
    }

    function calculateRetrogrades() {
      var retrogrades = [];
      var now = new Date();
      var past = new Date(now.getTime() - CONFIG.RETROGRADE_CHECK_DAYS * 24 * 60 * 60 * 1000);
      var future = new Date(now.getTime() + CONFIG.RETROGRADE_CHECK_DAYS * 24 * 60 * 60 * 1000);

      for (var i = 0; i < CONFIG.PLANETS_TO_CHECK.length; i++) {
        var planetName = CONFIG.PLANETS_TO_CHECK[i];
        try {
          var vecPast = Astronomy.GeoVector(planetName, past, false);
          var vecNow = Astronomy.GeoVector(planetName, now, false);
          var vecFuture = Astronomy.GeoVector(planetName, future, false);

          var eclPast = Astronomy.Ecliptic(vecPast);
          var eclNow = Astronomy.Ecliptic(vecNow);
          var eclFuture = Astronomy.Ecliptic(vecFuture);

          var lonPast = eclPast.elon;
          var lonNow = eclNow.elon;
          var lonFuture = eclFuture.elon;

          // Normalize to 0-360
          if (lonPast < 0) lonPast += 360;
          if (lonNow < 0) lonNow += 360;
          if (lonFuture < 0) lonFuture += 360;

          // Calculate deltas, handling 360° wrap
          var delta1 = lonNow - lonPast;
          var delta2 = lonFuture - lonNow;

          // Handle wraparound at 0/360
          if (delta1 > 180) delta1 -= 360;
          if (delta1 < -180) delta1 += 360;
          if (delta2 > 180) delta2 -= 360;
          if (delta2 < -180) delta2 += 360;

          // If both deltas are negative, planet is retrograde
          if (delta1 < 0 && delta2 < 0) {
            var signIndex = Math.floor(lonNow / 30) % 12;
            var sign = ZODIAC[signIndex];
            retrogrades.push({
              type: 'retrograde',
              planet: planetName,
              sign: sign.name,
              symbol: sign.symbol,
              longitude: lonNow,
              priority: 1
            });
          }
        } catch (e) {
          // Skip planets that fail calculation
          continue;
        }
      }

      return retrogrades;
    }

    function calculateNextEclipse() {
      var now = new Date();
      var maxDays = CONFIG.ASTRO_LOOKFORWARD_DAYS;
      var maxDate = new Date(now.getTime() + maxDays * 24 * 60 * 60 * 1000);

      try {
        var lunarEclipse = Astronomy.SearchLunarEclipse(now);
        var solarEclipse = Astronomy.SearchGlobalSolarEclipse(now);

        var nextEclipse = null;

        // Check lunar eclipse
        if (lunarEclipse && lunarEclipse.peak && new Date(lunarEclipse.peak.date) <= maxDate) {
          nextEclipse = {
            type: 'eclipse',
            eclipseType: 'lunar',
            kind: lunarEclipse.kind || 'partial',
            date: new Date(lunarEclipse.peak.date),
            priority: 2
          };
        }

        // Check solar eclipse
        if (solarEclipse && solarEclipse.peak && new Date(solarEclipse.peak.date) <= maxDate) {
          var solarDate = new Date(solarEclipse.peak.date);
          if (!nextEclipse || solarDate < nextEclipse.date) {
            nextEclipse = {
              type: 'eclipse',
              eclipseType: 'solar',
              kind: solarEclipse.kind || 'partial',
              date: solarDate,
              priority: 2
            };
          }
        }

        return nextEclipse ? [nextEclipse] : [];
      } catch (e) {
        return [];
      }
    }

    function calculatePlanetaryPositions() {
      var positions = [];
      var now = new Date();

      for (var i = 0; i < CONFIG.PLANETS_TO_CHECK.length; i++) {
        var planetName = CONFIG.PLANETS_TO_CHECK[i];
        try {
          var vec = Astronomy.GeoVector(planetName, now, false);
          var ecl = Astronomy.Ecliptic(vec);
          var lon = ecl.elon;
          if (lon < 0) lon += 360;

          var signIndex = Math.floor(lon / 30) % 12;
          var sign = ZODIAC[signIndex];
          var degrees = (lon % 30).toFixed(1);

          positions.push({
            type: 'position',
            planet: planetName,
            sign: sign.name,
            symbol: sign.symbol,
            longitude: lon,
            degrees: degrees,
            priority: 3
          });
        } catch (e) {
          continue;
        }
      }

      return positions;
    }

    function calculateLunarNodes() {
      var now = new Date();
      var maxDays = 30; // Only show if within 30 days

      try {
        var nextNode = Astronomy.SearchMoonNode(now);
        if (!nextNode || !nextNode.time) return [];

        var nodeDate = new Date(nextNode.time.date);
        var daysUntil = (nodeDate - now) / (1000 * 60 * 60 * 24);

        if (daysUntil > maxDays) return [];

        // Calculate zodiac position at node
        var moon = Astronomy.EclipticGeoMoon(nodeDate);
        var lon = moon.lon;
        if (lon < 0) lon += 360;
        var signIndex = Math.floor(lon / 30) % 12;
        var sign = ZODIAC[signIndex];

        return [{
          type: 'node',
          nodeType: nextNode.kind === 1 ? 'North' : 'South',
          sign: sign.name,
          symbol: sign.symbol,
          date: nodeDate,
          priority: 4
        }];
      } catch (e) {
        return [];
      }
    }

    function calculateAstroEvents() {
      var events = [];

      // Collect all events
      var retrogrades = calculateRetrogrades();
      var eclipses = calculateNextEclipse();
      var positions = calculatePlanetaryPositions();
      var nodes = calculateLunarNodes();

      events = events.concat(retrogrades);
      events = events.concat(eclipses);

      // Only show positions if we have fewer than 3 higher priority events
      var highPriorityCount = retrogrades.length + eclipses.length;
      if (highPriorityCount < 3) {
        events = events.concat(positions);
      }

      // Only show nodes if we have fewer than 5 total events
      if (events.length < 5) {
        events = events.concat(nodes);
      }

      // Sort by priority, then by date if both have dates
      events.sort(function(a, b) {
        if (a.priority !== b.priority) return a.priority - b.priority;
        if (a.date && b.date) return a.date - b.date;
        if (a.date) return -1;
        if (b.date) return 1;
        return 0;
      });

      return events;
    }

    function renderAstroEvents(events) {
      clearLoading('card-astro');
      var listEl = document.getElementById('astro-event-list');

      if (events.length === 0) {
        listEl.innerHTML = '<li class="no-astro-events">No significant astrological events detected.</li>';
        return;
      }

      var html = '';
      var now = new Date();

      for (var i = 0; i < events.length; i++) {
        var event = events[i];
        var iconClass = '';
        var iconText = '';
        var title = '';
        var detail = '';
        var dateText = '';

        if (event.type === 'retrograde') {
          iconClass = 'retrograde';
          iconText = '\u21BA'; // Retrograde symbol
          title = event.planet + ' Retrograde';
          detail = 'Currently in ' + event.symbol + ' ' + event.sign + ' (' + event.longitude.toFixed(1) + '\u00B0)';
        } else if (event.type === 'eclipse') {
          iconClass = 'eclipse';
          iconText = event.eclipseType === 'solar' ? '\u2600\uFE0F' : '\uD83C\uDF15';
          var kindName = event.kind.charAt(0).toUpperCase() + event.kind.slice(1);
          title = kindName + ' ' + (event.eclipseType === 'solar' ? 'Solar' : 'Lunar') + ' Eclipse';
          detail = 'Next occurrence';

          var daysUntil = Math.ceil((event.date - now) / (1000 * 60 * 60 * 24));
          if (daysUntil === 0) {
            dateText = 'Today';
          } else if (daysUntil === 1) {
            dateText = 'Tomorrow';
          } else if (daysUntil <= 7) {
            dateText = 'In ' + daysUntil + ' days';
          } else {
            dateText = event.date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
          }
        } else if (event.type === 'position') {
          iconClass = 'position';
          iconText = getPlanetEmoji(event.planet);
          title = event.planet + ' in ' + event.sign;
          detail = event.symbol + ' ' + event.degrees + '\u00B0 ' + event.sign;
        } else if (event.type === 'node') {
          iconClass = 'node';
          iconText = event.nodeType === 'North' ? '\u260A' : '\u260B';
          title = event.nodeType + ' Lunar Node';
          detail = 'Entering ' + event.symbol + ' ' + event.sign;

          var nodeDaysUntil = Math.ceil((event.date - now) / (1000 * 60 * 60 * 24));
          if (nodeDaysUntil === 0) {
            dateText = 'Today';
          } else if (nodeDaysUntil === 1) {
            dateText = 'Tomorrow';
          } else if (nodeDaysUntil <= 7) {
            dateText = 'In ' + nodeDaysUntil + ' days';
          } else {
            dateText = event.date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
          }
        }

        html += '<li class="astro-event-item">' +
          '<div class="astro-event-icon ' + iconClass + '">' + iconText + '</div>' +
          '<div class="astro-event-content">' +
            '<div class="astro-event-title">' + title + '</div>' +
            '<div class="astro-event-detail">' + detail + '</div>' +
            (dateText ? '<div class="astro-event-date">' + dateText + '</div>' : '') +
          '</div>' +
        '</li>';
      }

      listEl.innerHTML = html;
    }

    // ==========================================
    // SOLAR FLARES
    // ==========================================
    function fetchSolarFlares() {
      var end = new Date();
      var start = new Date();
      start.setDate(start.getDate() - CONFIG.SOLAR_LOOKBACK_DAYS);
      var url = CONFIG.SOLAR_FLARES_URL +
        '?startDate=' + formatDateISO(start) +
        '&endDate=' + formatDateISO(end);
      return fetchJSON(url).then(function(data) {
        if (!Array.isArray(data)) return [];
        data.sort(function(a, b) {
          return new Date(b.beginTime) - new Date(a.beginTime);
        });
        return data;
      });
    }

    function flareClassLetter(classType) {
      if (!classType) return 'B';
      var c = classType.charAt(0).toUpperCase();
      if (['B', 'C', 'M', 'X'].indexOf(c) !== -1) return c;
      return 'B';
    }

    function strongestFlare(flares) {
      var order = { B: 0, C: 1, M: 2, X: 3 };
      var best = null;
      var bestScore = -1;
      for (var i = 0; i < flares.length; i++) {
        var cls = flares[i].classType || '';
        var letter = flareClassLetter(cls);
        var num = parseFloat(cls.substring(1)) || 0;
        var score = (order[letter] || 0) * 100 + num;
        if (score > bestScore) {
          bestScore = score;
          best = cls;
        }
      }
      return best || 'None';
    }

    function renderSolar(flares) {
      clearLoading('card-solar');

      var summaryEl = document.getElementById('solar-summary');
      summaryEl.innerHTML =
        '<div class="solar-stat"><span class="val">' + flares.length + '</span>Events (last 7 days)</div>' +
        '<div class="solar-stat"><span class="val">' + strongestFlare(flares) + '</span>Strongest class</div>';

      var listEl = document.getElementById('flare-list');
      if (flares.length === 0) {
        listEl.innerHTML = '<li class="no-flares">No significant solar flare activity in the last 7 days.</li>';
        return;
      }

      var html = '';
      var limit = Math.min(flares.length, 15);
      for (var i = 0; i < limit; i++) {
        var f = flares[i];
        var letter = flareClassLetter(f.classType);
        html +=
          '<li class="flare-item">' +
            '<span class="flare-badge class-' + letter + '">' + (f.classType || '--') + '</span>' +
            '<span class="flare-time">' + formatDateTime(f.beginTime) + '</span>' +
            (f.sourceLocation ? '<span class="flare-source">' + f.sourceLocation + '</span>' : '') +
          '</li>';
      }
      if (flares.length > limit) {
        html += '<li class="flare-item" style="justify-content:center; color: var(--text-secondary); font-size:0.78rem;">+ ' +
          (flares.length - limit) + ' more</li>';
      }
      listEl.innerHTML = html;
    }

    // ==========================================
    // LOCATION DISPLAY HELPERS
    // ==========================================
    function locationDisplayName(loc) {
      var name = loc.city || '';
      if (loc.region) name += ', ' + loc.region;
      return name;
    }

    function updateLocationLabel(loc) {
      locLabel.textContent = locationDisplayName(loc);
      locationInput.value = locationDisplayName(loc);
    }

    // ==========================================
    // LOCATION EDITOR (expand / collapse)
    // ==========================================
    function openEditor() {
      locEditor.classList.add('open');
      locLabel.style.visibility = 'hidden';
      // Small delay so the click that opened doesn't immediately blur
      setTimeout(function() { locationInput.focus(); locationInput.select(); }, 50);
    }

    function closeEditor() {
      locEditor.classList.remove('open');
      locLabel.style.visibility = '';
      locationError.textContent = '';
    }

    // Click the label to open
    locLabel.addEventListener('click', function(e) {
      e.stopPropagation();
      openEditor();
    });

    // Close when clicking outside
    document.addEventListener('mousedown', function(e) {
      if (!locEditor.classList.contains('open')) return;
      if (locSwitcher.contains(e.target)) return;
      closeEditor();
    });

    // Close on Escape
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape' && locEditor.classList.contains('open')) {
        closeEditor();
      }
    });

    // "Go" button or Enter: geocode and reload
    function submitManualLocation() {
      var query = locationInput.value.trim();
      if (!query) {
        locationError.textContent = 'Enter a city or coordinates.';
        return;
      }
      locationError.textContent = '';
      locationGoBtn.disabled = true;
      locationGoBtn.textContent = '...';

      resolveLocationManual(query).then(function(loc) {
        locationGoBtn.disabled = false;
        locationGoBtn.textContent = 'Go';
        if (!loc) return; // error already shown
        updateLocationLabel(loc);
        closeEditor();

        // Save and reload pressure (solar + moon don't depend on location)
        var prefs = loadPrefs() || {};
        prefs.autoDetect = autoDetectToggle.checked;
        prefs.manual = loc;
        savePrefs(prefs);

        reloadPressure(loc);
      });
    }

    locationGoBtn.addEventListener('click', function() {
      submitManualLocation();
    });

    locationInput.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        submitManualLocation();
      }
    });

    // Auto-detect checkbox: when toggled on, immediately re-detect
    autoDetectToggle.addEventListener('change', function() {
      var prefs = loadPrefs() || {};
      prefs.autoDetect = autoDetectToggle.checked;
      savePrefs(prefs);

      if (autoDetectToggle.checked) {
        locationGoBtn.disabled = true;
        locationGoBtn.textContent = '...';
        detectLocationAuto().then(function(loc) {
          locationGoBtn.disabled = false;
          locationGoBtn.textContent = 'Go';
          updateLocationLabel(loc);
          closeEditor();
          prefs.manual = loc;
          savePrefs(prefs);
          reloadPressure(loc);
        });
      }
    });

    // ==========================================
    // RELOAD HELPERS
    // ==========================================
    function reloadPressure(loc) {
      setLoading('card-pressure');
      setLoading('card-temp');
      Promise.all([
        fetchPressure(loc.lat, loc.lon).then(renderPressure).catch(function() {
          showError('card-pressure', 'Failed to load pressure data.');
        }),
        fetchTemperature(loc.lat, loc.lon).then(renderTemperature).catch(function() {
          showError('card-temp', 'Failed to load temperature data.');
        })
      ]).then(function() {
        document.getElementById('last-updated').textContent =
          new Date().toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
      });
    }

    // ==========================================
    // INITIALIZATION
    // ==========================================
    function loadDashboard() {
      setLoading('card-pressure');
      setLoading('card-moon');
      setLoading('card-astro');
      setLoading('card-solar');
      setLoading('card-temp');

      // Moon is synchronous
      try {
        renderMoon(calculateMoon());
      } catch (e) {
        showError('card-moon', 'Could not calculate moon data.');
      }

      // Astrological events are synchronous
      try {
        var astroEvents = calculateAstroEvents();
        renderAstroEvents(astroEvents);
      } catch (e) {
        showError('card-astro', 'Could not calculate astrological events.');
      }

      // Solar flares (location-independent)
      fetchSolarFlares()
        .then(renderSolar)
        .catch(function() {
          showError('card-solar', 'Failed to load solar flare data.');
        });

      // Location + pressure + temperature
      resolveLocationForLoad().then(function(loc) {
        updateLocationLabel(loc);

        var prefs = loadPrefs() || {};
        prefs.autoDetect = autoDetectToggle.checked;
        prefs.manual = loc;
        savePrefs(prefs);

        // Fetch both pressure and temperature
        return Promise.all([
          fetchPressure(loc.lat, loc.lon).then(renderPressure).catch(function() {
            showError('card-pressure', 'Failed to load pressure data.');
          }),
          fetchTemperature(loc.lat, loc.lon).then(renderTemperature).catch(function() {
            showError('card-temp', 'Failed to load temperature data.');
          })
        ]);
      }).catch(function() {
        showError('card-pressure', 'Failed to load pressure data.');
        showError('card-temp', 'Failed to load temperature data.');
      }).then(function() {
        document.getElementById('last-updated').textContent =
          new Date().toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
      });
    }

    // Expose refresh for retry buttons
    window.__refresh = loadDashboard;

    document.getElementById('refresh-btn').addEventListener('click', loadDashboard);

    // Restore saved preferences
    (function restorePrefs() {
      var prefs = loadPrefs();
      if (prefs) {
        autoDetectToggle.checked = !!prefs.autoDetect;
      }
    })();

    // Boot
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', loadDashboard);
    } else {
      loadDashboard();
    }

  })();
  </script>
</body>
</html>
